// Code generated by MockGen. DO NOT EDIT.
// Source: scheduleServiceClient.go
//
// Generated by this command:
//
//	mockgen -source=scheduleServiceClient.go -destination=../mocks/schedule_serice_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	pkg "schedule_service/pkg/api"

	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockScheduleServiceClient is a mock of ScheduleServiceClient interface.
type MockScheduleServiceClient struct {
	ctrl     *gomock.Controller
	recorder *MockScheduleServiceClientMockRecorder
	isgomock struct{}
}

// MockScheduleServiceClientMockRecorder is the mock recorder for MockScheduleServiceClient.
type MockScheduleServiceClientMockRecorder struct {
	mock *MockScheduleServiceClient
}

// NewMockScheduleServiceClient creates a new mock instance.
func NewMockScheduleServiceClient(ctrl *gomock.Controller) *MockScheduleServiceClient {
	mock := &MockScheduleServiceClient{ctrl: ctrl}
	mock.recorder = &MockScheduleServiceClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduleServiceClient) EXPECT() *MockScheduleServiceClientMockRecorder {
	return m.recorder
}

// CancelLesson mocks base method.
func (m *MockScheduleServiceClient) CancelLesson(ctx context.Context, req *pkg.CancelLessonRequest, opts ...grpc.CallOption) (*pkg.Lesson, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CancelLesson", varargs...)
	ret0, _ := ret[0].(*pkg.Lesson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CancelLesson indicates an expected call of CancelLesson.
func (mr *MockScheduleServiceClientMockRecorder) CancelLesson(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelLesson", reflect.TypeOf((*MockScheduleServiceClient)(nil).CancelLesson), varargs...)
}

// CreateLesson mocks base method.
func (m *MockScheduleServiceClient) CreateLesson(ctx context.Context, req *pkg.CreateLessonRequest, opts ...grpc.CallOption) (*pkg.Lesson, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateLesson", varargs...)
	ret0, _ := ret[0].(*pkg.Lesson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateLesson indicates an expected call of CreateLesson.
func (mr *MockScheduleServiceClientMockRecorder) CreateLesson(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateLesson", reflect.TypeOf((*MockScheduleServiceClient)(nil).CreateLesson), varargs...)
}

// GetLesson mocks base method.
func (m *MockScheduleServiceClient) GetLesson(ctx context.Context, req *pkg.GetLessonRequest, opts ...grpc.CallOption) (*pkg.Lesson, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLesson", varargs...)
	ret0, _ := ret[0].(*pkg.Lesson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLesson indicates an expected call of GetLesson.
func (mr *MockScheduleServiceClientMockRecorder) GetLesson(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLesson", reflect.TypeOf((*MockScheduleServiceClient)(nil).GetLesson), varargs...)
}

// MarkAsPaid mocks base method.
func (m *MockScheduleServiceClient) MarkAsPaid(ctx context.Context, req *pkg.MarkAsPaidRequest, opts ...grpc.CallOption) (*pkg.Lesson, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MarkAsPaid", varargs...)
	ret0, _ := ret[0].(*pkg.Lesson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MarkAsPaid indicates an expected call of MarkAsPaid.
func (mr *MockScheduleServiceClientMockRecorder) MarkAsPaid(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAsPaid", reflect.TypeOf((*MockScheduleServiceClient)(nil).MarkAsPaid), varargs...)
}

// UpdateLesson mocks base method.
func (m *MockScheduleServiceClient) UpdateLesson(ctx context.Context, req *pkg.UpdateLessonRequest, opts ...grpc.CallOption) (*pkg.Lesson, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, req}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateLesson", varargs...)
	ret0, _ := ret[0].(*pkg.Lesson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateLesson indicates an expected call of UpdateLesson.
func (mr *MockScheduleServiceClientMockRecorder) UpdateLesson(ctx, req any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, req}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateLesson", reflect.TypeOf((*MockScheduleServiceClient)(nil).UpdateLesson), varargs...)
}
